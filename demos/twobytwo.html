<html>
  <head><script src="https://unpkg.com/pts/dist/pts.min.js"></script></head>

  <body style="font-family: sans-serif; margin: 0;">
    <div id="pt" style="width: 800px; height: 600px; margin: 30px auto 0;"></div>
    <div style="padding: 20px 0; font-family: sans-serif; font-size: 0.8em; color: #9ab; text-align: center;">
       Generated by <a href="https://ptsjs.org/demo/edit">Pts demo editor</a>. Learn more at <a href="https://ptsjs.org">https://ptsjs.org</a>.
     </div>

    <script>


// Source code licensed under Apache License 2.0. 
// Copyright © 2017 William Ngan. (https://github.com/williamngan/pts)

window.demoDescription = "2x2 matrices.";

  function transpose_(A, B) {
    A[0][0] = B[0][0];
    A[0][1] = B[1][0];
    A[1][0] = B[0][1];
    A[1][1] = B[1][1];
    return A;
  };

  function decompose_(gfpk, M) {
    gfpk[0][0] = (M[0][0]+M[1][1])/2;
    gfpk[0][1] = (M[0][0]-M[1][1])/2;
    gfpk[1][0] = (M[0][1]+M[1][0])/2;
    gfpk[1][1] = (M[0][1]-M[1][0])/2;
    return gfpk
  };

  function compose_(M, gfpk) {
    g = gfpk[0][0];
    f = gfpk[0][1];
    p = gfpk[1][0];
    k = gfpk[1][1];

    M[0][0] = g+f;
    M[0][1] = p+k;
    M[1][0] = p-k;
    M[1][1] = g-f;
    return M;
  }

  function swap_(gkpf, gfpk) {
    gkpf[0][0] = gfpk[0][0];
    gkpf[0][1] = gfpk[1][1];
    gkpf[1][0] = gfpk[1][0];
    gkpf[1][1] = gfpk[0][1];

    return gkpf;
  }
  
  function unswap_(gfpk, gkpf) {
    gfpk[0][0] = gkpf[0][0];
    gfpk[0][1] = gkpf[1][1];
    gfpk[1][0] = gkpf[1][0];
    gfpk[1][1] = gkpf[0][1];

    return gfpk;
  }

(function() {

  Pts.quickStart( "#pt", "#42e" ); 

  var M0 = [new Pt(1,3), new Pt(4,5)];

  var M = [new Pt(0,0), new Pt(0,0)];
  var MT = [new Pt(0,0), new Pt(0,0)];
  var gfpk = [new Pt(0,0), new Pt(0,0)];
  var gkpf = [new Pt(0,0), new Pt(0,0)];

  var origin = new Pt(0,0);
  var origin2 = new Pt(0,0);
  var handles;
  var scale = 50;

  function fromPt(pt) {
    return pt.$subtract(origin).divide(new Pt(scale, -scale));
  };

  function toPt(pt) {
    return pt.multiply(new Pt(scale, -scale)).add(origin);
  };

  function apply(transform, to, fr) {
     transform(to, fr.map(fromPt)).map(toPt);
  };

  function apply_all(M) {
    apply(transpose_, MT, M);
    apply(decompose_, gfpk, M);
    apply(swap_, gkpf, gfpk);
    gfpk.map(u=>{u.subtract(origin).add(origin2)});
    gkpf.map(u=>{u.subtract(origin).add(origin2)});

  };

  function print(origin_, pt) {
    pt = fromPt(pt.$subtract(origin_).add(origin));
    return "(" + pt[0].toFixed(1) + ", " + pt[1].toFixed(1) + ")";
  };

  function make_dragger(fn) {
      function make(h) {
        let ud = UIDragger.fromCircle( [h, [10,10]] );
        
        ud.onDrag( (ui, pt) => { // drag handling
          ui.group[0].to( space.pointer.$subtract( ui.state('offset') ) );
          fn();
          apply_all(M);
        });

        ud.onHover( // hover handling
          (ui) => ui.group[1].scale(1.5),
          (ui) => ui.group[1].scale(1/1.5),
        )
        return ud;
      }
      return make;
  }

  space.add( {

    start: (bound, space) => {      
      origin = space.center.$subtract(space.width/4, 0);
      origin2 = space.center.$add(space.width/4, 0);

      MT = M0.map(toPt);
      apply(transpose_, M, MT);
      apply_all(M);

      handles = M.map(make_dragger(()=>{}));
      handles = handles.concat(MT.map(make_dragger(()=>{
          apply(transpose_, M, MT)})));
      handles = handles.concat(gfpk.map(make_dragger(()=>{
          apply(compose_, M, gfpk.map(u=>{return u.$subtract(origin2).add(origin)}))})));
      handles = handles.concat(gkpf.map(make_dragger((u)=>{
          apply(unswap_, gfpk, gkpf.map(u=>{return u.$subtract(origin2).add(origin)})); 
          apply(compose_, M, gfpk);})));
    },   

    animate: (time, ftime) => {  
      // Circles    
      form.strokeOnly("#999").circle(Circle.fromRect([MT[0], M[0], M[0], MT[0]], 100));     
      form.strokeOnly("#999").circle(Circle.fromRect([MT[1], M[1], M[1], MT[1]], 100));     

      // Rows of M
      form.strokeOnly("#999", 2).line([MT[0], origin]);
      form.strokeOnly("#999", 2).line([MT[1], origin]);

      // Columns of M
      form.strokeOnly("#fff", 2).line([M[0], origin]);
      form.strokeOnly("#fff", 2).line([M[1], origin]);

      // Origins
      form.circle(Circle.fromCenter(origin, 3));
      form.circle(Circle.fromCenter(origin2, 3));

      // GUI handles
      form.fillOnly("#009");
      handles.forEach( h => h.render( g => form.circle(g) ) );

      // Text
      form.fillOnly("#fff");
      form.text(M[0].$add(-100, 0), "col1="+print(origin, M[0]));
      form.text(M[1].$add(0, -10), "col2="+print(origin, M[1]));
      form.text(MT[0], "row1="+print(origin, MT[0]));
      form.text(MT[1].$add(0,10), "row2="+print(origin, MT[1]));

      form.text(gfpk[0].$add(0, 10), "gf="+print(origin2, gfpk[0]));
      form.text(gfpk[1].$add(0, 10), "pk="+print(origin2, gfpk[1]));
      form.text(gkpf[0].$add(0, -10), "gk="+print(origin2, gkpf[0]));
      form.text(gkpf[1].$add(0, -10), "pf="+print(origin2, gkpf[1]));
      

      // Debug
    //   form.circle.fromCenter(new Pt(MT[0][0], (MT[0][1]+M[0][1])/2), MT[0][1]-M[0][1]);
    //   form.text(origin.$subtract(scale*3,10), "rows=" + print(origin, MT[0]));
    //   form.text(origin.$subtract(scale*3,-10),"          " +  print(origin, MT[1]));
    //   _M0 = toCoords(origin, M[0]);
    //   _M1 = toCoords(origin, M[1]);
    //   form.text(origin.$subtract(scale*3,100), "  M=" + _M0[0].toFixed(2) + "   " + _M1[0].toFixed(2));
    //   form.text(origin.$subtract(scale*3,80), "  " + _M0[1].toFixed(2) + "   " + _M1[1].toFixed(2));
    //   _M0 = toCoords(origin, MT[0]);
    //   _M1 = toCoords(origin, MT[1]);
    //   form.text(origin.$subtract(scale*3,60), "MT=" + _M0[0].toFixed(2) + "   " + _M1[0].toFixed(2));
    //   form.text(origin.$subtract(scale*3,40), "    " + _M0[1].toFixed(2) + "   " + _M1[1].toFixed(2));
    //   form.text(origin.$subtract(scale*3, -40), "g,f=" + print(origin, gfpk[0]));
    //   form.text(origin.$subtract(scale*3, -60), "p,k=" + print(origin, gfpk[1]));
    },

    action:( type, px, py) => {
      UI.track( handles, type, new Pt(px, py) );
    },
    
    resize:( bound, evt) => {
      if (form.ready) {

      }
    }
  });
    
  //// ----
  space.bindMouse().bindTouch().play();

})();


    </script>
  </body>
</html>